{
	// Place your Clang-Code 工作区 snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and 
	// description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope 
	// is left empty or omitted, the snippet gets applied to all languages. The prefix is what is 
	// used to trigger the snippet and the body will be expanded and inserted. Possible variables are: 
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. 
	// Placeholders with the same ids are connected.
	// Example:
	// "Print to console": {
	// 	"scope": "javascript,typescript",
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"DSU": {
		"scope": "cpp",
		"prefix": "DSU",
		"body": [
			"struct DSU {",
			"    std::vector<int> f, siz;",
			"    DSU(int n) : f(n), siz(n, 1) { std::iota(f.begin(), f.end(), 0); }",
			"    int find(int x) {",
			"        while (x != f[x]) x = f[x] = f[f[x]];",
			"        return x;",
			"    }",
			"    bool same(int x, int y) { return find(x) == find(y); }",
			"    bool merge(int x, int y) {",
			"        x = find(x); y = find(y);",
			"        if (x == y) return false;",
			"        siz[x] += siz[y];",
			"        f[y] = x;",
			"        return true;",
			"    }",
			"    int size(int x) { return siz[find(x)]; }",
			"};"
		],
		"description": "并查集"
	},
	"MInt": {
		"scope": "cpp",
		"prefix": "MInt",
		"body": [
			"template <class T>",
            "constexpr T power(T a, ll b) {",
            "    T res = 1;",
            "    for (; b; b /= 2, a *= a) {",
            "        if (b % 2) {",
            "            res *= a;",
            "        }",
            "    }",
            "    return res;",
            "}",
            "",
            "constexpr ll mul(ll a, ll b, ll p) {",
            "    ll res = a * b - ll(1.L * a * b / p) * p;",
            "    res %= p;",
            "    if (res < 0) {",
            "        res += p;",
            "    }",
            "    return res;",
            "}",
            "",
            "template <int P>",
            "struct MInt {",
            "    int x;",
            "    constexpr MInt() : x{} {}",
            "    constexpr MInt(ll x) : x{norm(x % getMod())} {}",
            "",
            "    static int Mod;",
            "    constexpr static int getMod() {",
            "        if (P > 0) {",
            "            return P;",
            "        } else {",
            "            return Mod;",
            "        }",
            "    }",
            "    constexpr static void setMod(int Mod_) { Mod = Mod_; }",
            "    constexpr int norm(int x) const {",
            "        if (x < 0) {",
            "            x += getMod();",
            "        }",
            "        if (x >= getMod()) {",
            "            x -= getMod();",
            "        }",
            "        return x;",
            "    }",
            "    constexpr int val() const { return x; }",
            "    explicit constexpr operator int() const { return x; }",
            "    constexpr MInt operator-() const {",
            "        MInt res;",
            "        res.x = norm(getMod() - x);",
            "        return res;",
            "    }",
            "    constexpr MInt inv() const {",
            "        assert(x != 0);",
            "        return power(*this, getMod() - 2);",
            "    }",
            "    constexpr MInt &operator*=(MInt rhs) & {",
            "        x = 1LL * x * rhs.x % getMod();",
            "        return *this;",
            "    }",
            "    constexpr MInt &operator+=(MInt rhs) & {",
            "        x = norm(x + rhs.x);",
            "        return *this;",
            "    }",
            "    constexpr MInt &operator-=(MInt rhs) & {",
            "        x = norm(x - rhs.x);",
            "        return *this;",
            "    }",
            "    constexpr MInt &operator/=(MInt rhs) & { return *this *= rhs.inv(); }",
            "    friend constexpr MInt operator*(MInt lhs, MInt rhs) {",
            "        MInt res = lhs;",
            "        res *= rhs;",
            "        return res;",
            "    }",
            "    friend constexpr MInt operator+(MInt lhs, MInt rhs) {",
            "        MInt res = lhs;",
            "        res += rhs;",
            "        return res;",
            "    }",
            "    friend constexpr MInt operator-(MInt lhs, MInt rhs) {",
            "        MInt res = lhs;",
            "        res -= rhs;",
            "        return res;",
            "    }",
            "    friend constexpr MInt operator/(MInt lhs, MInt rhs) {",
            "        MInt res = lhs;",
            "        res /= rhs;",
            "        return res;",
            "    }",
            "    friend constexpr std::istream &operator>>(std::istream &is, MInt &a) {",
            "        ll v;",
            "        is >> v;",
            "        a = MInt(v);",
            "        return is;",
            "    }",
            "    friend constexpr std::ostream &operator<<(std::ostream &os, const MInt &a) {",
            "        return os << a.val();",
            "    }",
            "    friend constexpr bool operator==(MInt lhs, MInt rhs) {",
            "        return lhs.val() == rhs.val();",
            "    }",
            "    friend constexpr bool operator!=(MInt lhs, MInt rhs) {",
            "        return lhs.val() != rhs.val();",
            "    }",
            "};",
            "//-------------------------------------//",
            "template <>",
            "// int MInt<0>::Mod = 1E9+7;",
            "int MInt<0>::Mod = 998244353;",
            "",
            "template <int V, int P>",
            "constexpr MInt<P> CInv = MInt<P>(V).inv();",
            "",
            "// constexpr int P = 1E9+7;",
            "constexpr int P = 998244353;",
            "using Z = MInt<P>;",
            "//-------------------------------------//",
            "",
            "Z fac[N], invfac[N];",
            "",
            "void INIT() {",
            "    fac[0] = invfac[0] = 1;",
            "    for (int i = 1; i < N; i++) fac[i] = fac[i - 1] * i;",
            "    invfac[N - 1] = fac[N - 1].inv();",
            "    for (int i = N - 2; i; i--) invfac[i] = invfac[i + 1] * (i + 1);",
            "}",
            "inline Z A(int a, int b) {",
            "    if (a < 0 || b < 0 || a < b) return 0;",
            "    return fac[a] * invfac[a - b];",
            "}",
            "inline Z C(int a, int b) {",
            "    if (a < 0 || b < 0 || a < b) return 0;",
            "    return fac[a] * invfac[b] * invfac[a - b];",
            "}"
		],
		"description": "自动取模与组合数"
	},
	"power": {
        "scope": "c,cpp",
        "prefix": "power",
        "body": [
            "template<class T>",
            "constexpr T power(T a, ll b, ll mod) {",
            "    a %= mod;",
            "    T res = 1;",
            "    for (; b; b /= 2, a *= a, a %= mod) {",
            "        if (b % 2) {",
            "            res *= a;",
            "            res %= mod;",
            "        }",
            "    }",
            "    return res;",
            "}"
        ],
        "description": "快速幂（自定义模数）"
    },
	"SegmentTree Template": {
        "scope": "c,cpp",
        "prefix": "SegmentTree",
        "body": [
            "template<class Info>",
            "struct SegmentTree {",
            "    int n;",
            "    std::vector<Info> info;",
            "    SegmentTree() : n(0) {}",
            "    SegmentTree(int n_, Info v_ = Info()) {",
            "        init(n_, v_);",
            "    }",
            "    template<class T>",
            "    SegmentTree(std::vector<T> init_) {",
            "        init(init_);",
            "    }",
            "    void init(int n_, Info v_ = Info()) {",
            "        init(std::vector(n_, v_));",
            "    }",
            "    template<class T>",
            "    void init(std::vector<T> init_) {",
            "        n = init_.size();",
            "        info.assign(4 << __lg(n), Info());",
            "        std::function<void(int, int, int)> build = [&](int p, int l, int r) {",
            "            if (r - l == 1) {",
            "                info[p] = init_[l];",
            "                return;",
            "            }",
            "            int m = (l + r) / 2;",
            "            build(2 * p, l, m);",
            "            build(2 * p + 1, m, r);",
            "            pull(p);",
            "        };",
            "        build(1, 0, n);",
            "    }",
            "    void pull(int p) {",
            "        info[p] = info[2 * p] + info[2 * p + 1];",
            "    }",
            "    void modify(int p, int l, int r, int x, const Info &v) {",
            "        if (r - l == 1) {",
            "            info[p] = v;",
            "            return;",
            "        }",
            "        int m = (l + r) / 2;",
            "        if (x < m) {",
            "            modify(2 * p, l, m, x, v);",
            "        } else {",
            "            modify(2 * p + 1, m, r, x, v);",
            "        }",
            "        pull(p);",
            "    }",
            "    void modify(int p, const Info &v) {",
            "        modify(1, 0, n, p, v);",
            "    }",
            "    Info rangeQuery(int p, int l, int r, int x, int y) {",
            "        if (l >= y || r <= x) {",
            "            return Info();",
            "        }",
            "        if (l >= x && r <= y) {",
            "            return info[p];",
            "        }",
            "        int m = (l + r) / 2;",
            "        return rangeQuery(2 * p, l, m, x, y) + rangeQuery(2 * p + 1, m, r, x, y);",
            "    }",
            "    Info rangeQuery(int l, int r) {",
            "        return rangeQuery(1, 0, n, l, r);",
            "    }",
            "    template<class F>",
            "    int findFirst(int p, int l, int r, int x, int y, F pred) {",
            "        if (l >= y || r <= x || !pred(info[p])) {",
            "            return -1;",
            "        }",
            "        if (r - l == 1) {",
            "            return l;",
            "        }",
            "        int m = (l + r) / 2;",
            "        int res = findFirst(2 * p, l, m, x, y, pred);",
            "        if (res == -1) {",
            "            res = findFirst(2 * p + 1, m, r, x, y, pred);",
            "        }",
            "        return res;",
            "    }",
            "    template<class F>",
            "    int findFirst(int l, int r, F pred) {",
            "        return findFirst(1, 0, n, l, r, pred);",
            "    }",
            "    template<class F>",
            "    int findLast(int p, int l, int r, int x, int y, F pred) {",
            "        if (l >= y || r <= x || !pred(info[p])) {",
            "            return -1;",
            "        }",
            "        if (r - l == 1) {",
            "            return l;",
            "        }",
            "        int m = (l + r) / 2;",
            "        int res = findLast(2 * p + 1, m, r, x, y, pred);",
            "        if (res == -1) {",
            "            res = findLast(2 * p, l, m, x, y, pred);",
            "        }",
            "        return res;",
            "    }",
            "    template<class F>",
            "    int findLast(int l, int r, F pred) {",
            "        return findLast(1, 0, n, l, r, pred);",
            "    }",
            "};",
            "",
            "struct Info {",
            "    int sum = 0;",
            "\tint mx = -INF;",
            "\tint mn = INF;",
            "};",
            "",
            "Info operator+(Info a, Info b) {",
            "    Info c;",
            "    c.sum = a.sum + b.sum;",
            "    c.mx = max(a.mx, b.mx);",
            "    c.mn = min(a.mn, b.mn);",
            "    return c;",
            "}"
        ],
        "description": "线段树模板"
    },
	"LazySegmentTree Template": {
        "scope": "c,cpp",
        "prefix": "LazySegmentTree",
        "body": [
            "template <class Info, class Tag>",
            "struct LazySegmentTree {",
            "    int n;",
            "    std::vector<Info> info;",
            "    std::vector<Tag> tag;",
            "    LazySegmentTree() : n(0) {}",
            "    LazySegmentTree(int n_, Info v_ = Info()) { init(n_, v_); }",
            "    template <class T>",
            "    LazySegmentTree(std::vector<T> init_) {",
            "        init(init_);",
            "    }",
            "    void init(int n_, Info v_ = Info()) { init(std::vector(n_, v_)); }",
            "    template <class T>",
            "    void init(std::vector<T> init_) {",
            "        n = init_.size();",
            "        info.assign(4 << __lg(n), Info());",
            "        tag.assign(4 << __lg(n), Tag());",
            "        std::function<void(int, int, int)> build = [&](int p, int l, int r) {",
            "            if (r - l == 1) {",
            "                info[p] = init_[l];",
            "                return;",
            "            }",
            "            int m = (l + r) / 2;",
            "            build(2 * p, l, m);",
            "            build(2 * p + 1, m, r);",
            "            pull(p);",
            "        };",
            "        build(1, 0, n);",
            "    }",
            "    void pull(int p) { info[p] = info[2 * p] + info[2 * p + 1]; }",
            "    void apply(int p, const Tag &v) {",
            "        info[p].apply(v);",
            "        tag[p].apply(v);",
            "    }",
            "    void push(int p) {",
            "        apply(2 * p, tag[p]);",
            "        apply(2 * p + 1, tag[p]);",
            "        tag[p] = Tag();",
            "    }",
            "    void modify(int p, int l, int r, int x, const Info &v) {",
            "        if (r - l == 1) {",
            "            info[p] = v;",
            "            return;",
            "        }",
            "        int m = (l + r) / 2;",
            "        push(p);",
            "        if (x < m) {",
            "            modify(2 * p, l, m, x, v);",
            "        } else {",
            "            modify(2 * p + 1, m, r, x, v);",
            "        }",
            "        pull(p);",
            "    }",
            "    void modify(int p, const Info &v) { modify(1, 0, n, p, v); }",
            "    Info rangeQuery(int p, int l, int r, int x, int y) {",
            "        if (l >= y || r <= x) {",
            "            return Info();",
            "        }",
            "        if (l >= x && r <= y) {",
            "            return info[p];",
            "        }",
            "        int m = (l + r) / 2;",
            "        push(p);",
            "        return rangeQuery(2 * p, l, m, x, y) +",
            "               rangeQuery(2 * p + 1, m, r, x, y);",
            "    }",
            "    Info rangeQuery(int l, int r) { return rangeQuery(1, 0, n, l, r); }",
            "    void rangeApply(int p, int l, int r, int x, int y, const Tag &v) {",
            "        if (l >= y || r <= x) {",
            "            return;",
            "        }",
            "        if (l >= x && r <= y) {",
            "            apply(p, v);",
            "            return;",
            "        }",
            "        int m = (l + r) / 2;",
            "        push(p);",
            "        rangeApply(2 * p, l, m, x, y, v);",
            "        rangeApply(2 * p + 1, m, r, x, y, v);",
            "        pull(p);",
            "    }",
            "    void rangeApply(int l, int r, const Tag &v) {",
            "        return rangeApply(1, 0, n, l, r, v);",
            "    }",
            "    template <class F>",
            "    int findFirst(int p, int l, int r, int x, int y, F pred) {",
            "        if (l >= y || r <= x || !pred(info[p])) {",
            "            return -1;",
            "        }",
            "        if (r - l == 1) {",
            "            return l;",
            "        }",
            "        int m = (l + r) / 2;",
            "        push(p);",
            "        int res = findFirst(2 * p, l, m, x, y, pred);",
            "        if (res == -1) {",
            "            res = findFirst(2 * p + 1, m, r, x, y, pred);",
            "        }",
            "        return res;",
            "    }",
            "    template <class F>",
            "    int findFirst(int l, int r, F pred) {",
            "        return findFirst(1, 0, n, l, r, pred);",
            "    }",
            "    template <class F>",
            "    int findLast(int p, int l, int r, int x, int y, F pred) {",
            "        if (l >= y || r <= x || !pred(info[p])) {",
            "            return -1;",
            "        }",
            "        if (r - l == 1) {",
            "            return l;",
            "        }",
            "        int m = (l + r) / 2;",
            "        push(p);",
            "        int res = findLast(2 * p + 1, m, r, x, y, pred);",
            "        if (res == -1) {",
            "            res = findLast(2 * p, l, m, x, y, pred);",
            "        }",
            "        return res;",
            "    }",
            "    template <class F>",
            "    int findLast(int l, int r, F pred) {",
            "        return findLast(1, 0, n, l, r, pred);",
            "    }",
            "};",
            "",
            "struct Tag {",
            "    int add = 0;",
            "    void apply(Tag t) {  // 两个懒标记结合",
            "        add += t.add;",
            "    }",
            "};",
            "",
            "struct Info {",
            "    int sum = 0;",
            "    int len = 1;",
            "    int mx = -INF;",
            "    int mn = INF;",
            "    void apply(Tag t) {  // 懒标记作用到信息上",
            "        sum += t.add * len;",
            "        mx += t.add;",
            "        mn += t.add;",
            "    }",
            "};",
            "Info operator+(Info a, Info b) {",
            "    Info c;",
            "    c.sum = a.sum + b.sum;",
            "    c.len = a.len + b.len;",
            "    c.mx = max(a.mx, b.mx);",
            "    c.mn = min(a.mn, b.mn);",
            "    return c;",
            "}"
        ],
        "description": "线段树（懒标记）模板"
    },
	"Tree Template": {
        "scope": "c,cpp",
        "prefix": "Tree",
        "body": [
            "struct Tree {",
            "    int n;",
            "    vector<vector<int>> g;",
            "    vector<int> fa, dep, sz, son, top, val;",
            "    int pr[N], sf[N];",
            "    Tree(int n_) : n(n_), g(n), fa(n), dep(n), sz(n), son(n), top(n), val(n) {}",
            "",
            "    inline void add_edge(int u, int v) {",
            "        g[u].push_back(v);",
            "        g[v].push_back(u);",
            "    }",
            "    void dfs1(int u) {",
            "        sz[u] = 1;",
            "        dep[u] = dep[fa[u]] + 1;",
            "        for (auto v : g[u]) {",
            "            if (v == fa[u]) continue;",
            "            fa[v] = u;",
            "            dfs1(v);",
            "            sz[u] += sz[v];",
            "            if (sz[v] > sz[son[u]]) son[u] = v;",
            "        }",
            "    }",
            "    void dfs2(int u, int h) {",
            "        top[u] = h;",
            "        if (son[u]) dfs2(son[u], h);",
            "        for (auto v : g[u]) {",
            "            if (v == fa[u] || v == son[u]) continue;",
            "            dfs2(v, v);",
            "        }",
            "    }",
            "    int LCA(int x, int y) {",
            "        while (top[x] != top[y]) {",
            "            if (dep[top[x]] > dep[top[y]]) x = fa[top[x]];",
            "            else y = fa[top[y]];",
            "        }",
            "        return dep[x] < dep[y] ? x : y;",
            "    }",
            "    void init() {",
            "        dfs1(1);",
            "        dfs2(1, 1);",
            "    }",
            "};"
        ],
        "description": "Tree Template with LCA and HLD"
    },
	"Linear Sieve Function": {
        "scope": "c,cpp",
        "prefix": "get_primes",
        "body": [
            "//---线性筛----//",
            "vector<int> primes;",
            "vector<bool> isp;",
            "void get_primes(int n) {",
            "    isp.assign(n + 1, true);",
            "    isp[0] = isp[1] = false;",
            "    primes.clear();",
            "    for (int i = 2; i <= n; i++) {",
            "        if (isp[i]) primes.push_back(i);",
            "        for (int j = 0; j < primes.size() && primes[j] <= n / i; j++) {",
            "            isp[primes[j] * i] = false;",
            "            if (i % primes[j] == 0) break;",
            "        }",
            "    }",
            "}"
        ],
        "description": "Linear Sieve to find all primes up to n"
    }
}