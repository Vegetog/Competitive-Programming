{
	// Place your Clang-Code 工作区 snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and 
	// description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope 
	// is left empty or omitted, the snippet gets applied to all languages. The prefix is what is 
	// used to trigger the snippet and the body will be expanded and inserted. Possible variables are: 
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. 
	// Placeholders with the same ids are connected.
	// Example:
	// "Print to console": {
	// 	"scope": "javascript,typescript",
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"DSU": {
		"scope": "cpp",
		"prefix": "DSU",
		"body": [
			"struct DSU {",
			"    std::vector<int> f, siz;",
			"    DSU(int n) : f(n), siz(n, 1) { std::iota(f.begin(), f.end(), 0); }",
			"    int find(int x) {",
			"        while (x != f[x]) x = f[x] = f[f[x]];",
			"        return x;",
			"    }",
			"    bool same(int x, int y) { return find(x) == find(y); }",
			"    bool merge(int x, int y) {",
			"        x = find(x); y = find(y);",
			"        if (x == y) return false;",
			"        siz[x] += siz[y];",
			"        f[y] = x;",
			"        return true;",
			"    }",
			"    int size(int x) { return siz[find(x)]; }",
			"};"
		],
		"description": "并查集"
	},
	"MInt": {
		"scope": "cpp",
		"prefix": "MInt",
		"body": [
			"template <class T>",
            "constexpr T power(T a, ll b) {",
            "    T res = 1;",
            "    for (; b; b /= 2, a *= a) {",
            "        if (b % 2) {",
            "            res *= a;",
            "        }",
            "    }",
            "    return res;",
            "}",
            "",
            "constexpr ll mul(ll a, ll b, ll p) {",
            "    ll res = a * b - ll(1.L * a * b / p) * p;",
            "    res %= p;",
            "    if (res < 0) {",
            "        res += p;",
            "    }",
            "    return res;",
            "}",
            "",
            "template <int P>",
            "struct MInt {",
            "    int x;",
            "    constexpr MInt() : x{} {}",
            "    constexpr MInt(ll x) : x{norm(x % getMod())} {}",
            "",
            "    static int Mod;",
            "    constexpr static int getMod() {",
            "        if (P > 0) {",
            "            return P;",
            "        } else {",
            "            return Mod;",
            "        }",
            "    }",
            "    constexpr static void setMod(int Mod_) { Mod = Mod_; }",
            "    constexpr int norm(int x) const {",
            "        if (x < 0) {",
            "            x += getMod();",
            "        }",
            "        if (x >= getMod()) {",
            "            x -= getMod();",
            "        }",
            "        return x;",
            "    }",
            "    constexpr int val() const { return x; }",
            "    explicit constexpr operator int() const { return x; }",
            "    constexpr MInt operator-() const {",
            "        MInt res;",
            "        res.x = norm(getMod() - x);",
            "        return res;",
            "    }",
            "    constexpr MInt inv() const {",
            "        assert(x != 0);",
            "        return power(*this, getMod() - 2);",
            "    }",
            "    constexpr MInt &operator*=(MInt rhs) & {",
            "        x = 1LL * x * rhs.x % getMod();",
            "        return *this;",
            "    }",
            "    constexpr MInt &operator+=(MInt rhs) & {",
            "        x = norm(x + rhs.x);",
            "        return *this;",
            "    }",
            "    constexpr MInt &operator-=(MInt rhs) & {",
            "        x = norm(x - rhs.x);",
            "        return *this;",
            "    }",
            "    constexpr MInt &operator/=(MInt rhs) & { return *this *= rhs.inv(); }",
            "    friend constexpr MInt operator*(MInt lhs, MInt rhs) {",
            "        MInt res = lhs;",
            "        res *= rhs;",
            "        return res;",
            "    }",
            "    friend constexpr MInt operator+(MInt lhs, MInt rhs) {",
            "        MInt res = lhs;",
            "        res += rhs;",
            "        return res;",
            "    }",
            "    friend constexpr MInt operator-(MInt lhs, MInt rhs) {",
            "        MInt res = lhs;",
            "        res -= rhs;",
            "        return res;",
            "    }",
            "    friend constexpr MInt operator/(MInt lhs, MInt rhs) {",
            "        MInt res = lhs;",
            "        res /= rhs;",
            "        return res;",
            "    }",
            "    friend constexpr std::istream &operator>>(std::istream &is, MInt &a) {",
            "        ll v;",
            "        is >> v;",
            "        a = MInt(v);",
            "        return is;",
            "    }",
            "    friend constexpr std::ostream &operator<<(std::ostream &os, const MInt &a) {",
            "        return os << a.val();",
            "    }",
            "    friend constexpr bool operator==(MInt lhs, MInt rhs) {",
            "        return lhs.val() == rhs.val();",
            "    }",
            "    friend constexpr bool operator!=(MInt lhs, MInt rhs) {",
            "        return lhs.val() != rhs.val();",
            "    }",
            "};",
            "//-------------------------------------//",
            "template <>",
            "// int MInt<0>::Mod = 1E9+7;",
            "int MInt<0>::Mod = 998244353;",
            "",
            "template <int V, int P>",
            "constexpr MInt<P> CInv = MInt<P>(V).inv();",
            "",
            "// constexpr int P = 1E9+7;",
            "constexpr int P = 998244353;",
            "using Z = MInt<P>;",
            "//-------------------------------------//",
            "",
            "Z fac[N], invfac[N];",
            "",
            "void INIT() {",
            "    fac[0] = invfac[0] = 1;",
            "    for (int i = 1; i < N; i++) fac[i] = fac[i - 1] * i;",
            "    invfac[N - 1] = fac[N - 1].inv();",
            "    for (int i = N - 2; i; i--) invfac[i] = invfac[i + 1] * (i + 1);",
            "}",
            "inline Z A(int a, int b) {",
            "    if (a < 0 || b < 0 || a < b) return 0;",
            "    return fac[a] * invfac[a - b];",
            "}",
            "inline Z C(int a, int b) {",
            "    if (a < 0 || b < 0 || a < b) return 0;",
            "    return fac[a] * invfac[b] * invfac[a - b];",
            "}"
		],
		"description": "自动取模与组合数"
	},
	"power": {
        "scope": "c,cpp",
        "prefix": "power",
        "body": [
            "template<class T>",
            "constexpr T power(T a, ll b, ll mod) {",
            "    a %= mod;",
            "    T res = 1;",
            "    for (; b; b /= 2, a *= a, a %= mod) {",
            "        if (b % 2) {",
            "            res *= a;",
            "            res %= mod;",
            "        }",
            "    }",
            "    return res;",
            "}"
        ],
        "description": "快速幂（自定义模数）"
    },
	"SegmentTree Template": {
        "scope": "c,cpp",
        "prefix": "SegmentTree",
        "body": [
            "template<class Info>",
            "struct SegmentTree {",
            "    int n;",
            "    std::vector<Info> info;",
            "    SegmentTree() : n(0) {}",
            "    SegmentTree(int n_, Info v_ = Info()) {",
            "        init(n_, v_);",
            "    }",
            "    template<class T>",
            "    SegmentTree(std::vector<T> init_) {",
            "        init(init_);",
            "    }",
            "    void init(int n_, Info v_ = Info()) {",
            "        init(std::vector(n_, v_));",
            "    }",
            "    template<class T>",
            "    void init(std::vector<T> init_) {",
            "        n = init_.size();",
            "        info.assign(4 << __lg(n), Info());",
            "        std::function<void(int, int, int)> build = [&](int p, int l, int r) {",
            "            if (r - l == 1) {",
            "                info[p] = init_[l];",
            "                return;",
            "            }",
            "            int m = (l + r) / 2;",
            "            build(2 * p, l, m);",
            "            build(2 * p + 1, m, r);",
            "            pull(p);",
            "        };",
            "        build(1, 0, n);",
            "    }",
            "    void pull(int p) {",
            "        info[p] = info[2 * p] + info[2 * p + 1];",
            "    }",
            "    void modify(int p, int l, int r, int x, const Info &v) {",
            "        if (r - l == 1) {",
            "            info[p] = v;",
            "            return;",
            "        }",
            "        int m = (l + r) / 2;",
            "        if (x < m) {",
            "            modify(2 * p, l, m, x, v);",
            "        } else {",
            "            modify(2 * p + 1, m, r, x, v);",
            "        }",
            "        pull(p);",
            "    }",
            "    void modify(int p, const Info &v) {",
            "        modify(1, 0, n, p, v);",
            "    }",
            "    Info rangeQuery(int p, int l, int r, int x, int y) {",
            "        if (l >= y || r <= x) {",
            "            return Info();",
            "        }",
            "        if (l >= x && r <= y) {",
            "            return info[p];",
            "        }",
            "        int m = (l + r) / 2;",
            "        return rangeQuery(2 * p, l, m, x, y) + rangeQuery(2 * p + 1, m, r, x, y);",
            "    }",
            "    Info rangeQuery(int l, int r) {",
            "        return rangeQuery(1, 0, n, l, r);",
            "    }",
            "    template<class F>",
            "    int findFirst(int p, int l, int r, int x, int y, F pred) {",
            "        if (l >= y || r <= x || !pred(info[p])) {",
            "            return -1;",
            "        }",
            "        if (r - l == 1) {",
            "            return l;",
            "        }",
            "        int m = (l + r) / 2;",
            "        int res = findFirst(2 * p, l, m, x, y, pred);",
            "        if (res == -1) {",
            "            res = findFirst(2 * p + 1, m, r, x, y, pred);",
            "        }",
            "        return res;",
            "    }",
            "    template<class F>",
            "    int findFirst(int l, int r, F pred) {",
            "        return findFirst(1, 0, n, l, r, pred);",
            "    }",
            "    template<class F>",
            "    int findLast(int p, int l, int r, int x, int y, F pred) {",
            "        if (l >= y || r <= x || !pred(info[p])) {",
            "            return -1;",
            "        }",
            "        if (r - l == 1) {",
            "            return l;",
            "        }",
            "        int m = (l + r) / 2;",
            "        int res = findLast(2 * p + 1, m, r, x, y, pred);",
            "        if (res == -1) {",
            "            res = findLast(2 * p, l, m, x, y, pred);",
            "        }",
            "        return res;",
            "    }",
            "    template<class F>",
            "    int findLast(int l, int r, F pred) {",
            "        return findLast(1, 0, n, l, r, pred);",
            "    }",
            "};",
            "",
            "struct Info {",
            "    int sum = 0;",
            "\tint mx = -INF;",
            "\tint mn = INF;",
            "};",
            "",
            "Info operator+(Info a, Info b) {",
            "    Info c;",
            "    c.sum = a.sum + b.sum;",
            "    c.mx = max(a.mx, b.mx);",
            "    c.mn = min(a.mn, b.mn);",
            "    return c;",
            "}"
        ],
        "description": "线段树模板"
    },
	"LazySegmentTree Template": {
        "scope": "c,cpp",
        "prefix": "LazySegmentTree",
        "body": [
            "template <class Info, class Tag>",
            "struct LazySegmentTree {",
            "    int n;",
            "    std::vector<Info> info;",
            "    std::vector<Tag> tag;",
            "    LazySegmentTree() : n(0) {}",
            "    LazySegmentTree(int n_, Info v_ = Info()) { init(n_, v_); }",
            "    template <class T>",
            "    LazySegmentTree(std::vector<T> init_) {",
            "        init(init_);",
            "    }",
            "    void init(int n_, Info v_ = Info()) { init(std::vector(n_, v_)); }",
            "    template <class T>",
            "    void init(std::vector<T> init_) {",
            "        n = init_.size();",
            "        info.assign(4 << __lg(n), Info());",
            "        tag.assign(4 << __lg(n), Tag());",
            "        std::function<void(int, int, int)> build = [&](int p, int l, int r) {",
            "            if (r - l == 1) {",
            "                info[p] = init_[l];",
            "                return;",
            "            }",
            "            int m = (l + r) / 2;",
            "            build(2 * p, l, m);",
            "            build(2 * p + 1, m, r);",
            "            pull(p);",
            "        };",
            "        build(1, 0, n);",
            "    }",
            "    void pull(int p) { info[p] = info[2 * p] + info[2 * p + 1]; }",
            "    void apply(int p, const Tag &v) {",
            "        info[p].apply(v);",
            "        tag[p].apply(v);",
            "    }",
            "    void push(int p) {",
            "        apply(2 * p, tag[p]);",
            "        apply(2 * p + 1, tag[p]);",
            "        tag[p] = Tag();",
            "    }",
            "    void modify(int p, int l, int r, int x, const Info &v) {",
            "        if (r - l == 1) {",
            "            info[p] = v;",
            "            return;",
            "        }",
            "        int m = (l + r) / 2;",
            "        push(p);",
            "        if (x < m) {",
            "            modify(2 * p, l, m, x, v);",
            "        } else {",
            "            modify(2 * p + 1, m, r, x, v);",
            "        }",
            "        pull(p);",
            "    }",
            "    void modify(int p, const Info &v) { modify(1, 0, n, p, v); }",
            "    Info rangeQuery(int p, int l, int r, int x, int y) {",
            "        if (l >= y || r <= x) {",
            "            return Info();",
            "        }",
            "        if (l >= x && r <= y) {",
            "            return info[p];",
            "        }",
            "        int m = (l + r) / 2;",
            "        push(p);",
            "        return rangeQuery(2 * p, l, m, x, y) +",
            "               rangeQuery(2 * p + 1, m, r, x, y);",
            "    }",
            "    Info rangeQuery(int l, int r) { return rangeQuery(1, 0, n, l, r); }",
            "    void rangeApply(int p, int l, int r, int x, int y, const Tag &v) {",
            "        if (l >= y || r <= x) {",
            "            return;",
            "        }",
            "        if (l >= x && r <= y) {",
            "            apply(p, v);",
            "            return;",
            "        }",
            "        int m = (l + r) / 2;",
            "        push(p);",
            "        rangeApply(2 * p, l, m, x, y, v);",
            "        rangeApply(2 * p + 1, m, r, x, y, v);",
            "        pull(p);",
            "    }",
            "    void rangeApply(int l, int r, const Tag &v) {",
            "        return rangeApply(1, 0, n, l, r, v);",
            "    }",
            "    template <class F>",
            "    int findFirst(int p, int l, int r, int x, int y, F pred) {",
            "        if (l >= y || r <= x || !pred(info[p])) {",
            "            return -1;",
            "        }",
            "        if (r - l == 1) {",
            "            return l;",
            "        }",
            "        int m = (l + r) / 2;",
            "        push(p);",
            "        int res = findFirst(2 * p, l, m, x, y, pred);",
            "        if (res == -1) {",
            "            res = findFirst(2 * p + 1, m, r, x, y, pred);",
            "        }",
            "        return res;",
            "    }",
            "    template <class F>",
            "    int findFirst(int l, int r, F pred) {",
            "        return findFirst(1, 0, n, l, r, pred);",
            "    }",
            "    template <class F>",
            "    int findLast(int p, int l, int r, int x, int y, F pred) {",
            "        if (l >= y || r <= x || !pred(info[p])) {",
            "            return -1;",
            "        }",
            "        if (r - l == 1) {",
            "            return l;",
            "        }",
            "        int m = (l + r) / 2;",
            "        push(p);",
            "        int res = findLast(2 * p + 1, m, r, x, y, pred);",
            "        if (res == -1) {",
            "            res = findLast(2 * p, l, m, x, y, pred);",
            "        }",
            "        return res;",
            "    }",
            "    template <class F>",
            "    int findLast(int l, int r, F pred) {",
            "        return findLast(1, 0, n, l, r, pred);",
            "    }",
            "};",
            "",
            "struct Tag {",
            "    int add = 0;",
            "    void apply(Tag t) {  // 两个懒标记结合",
            "        add += t.add;",
            "    }",
            "};",
            "",
            "struct Info {",
            "    int sum = 0;",
            "    int len = 1;",
            "    int mx = -INF;",
            "    int mn = INF;",
            "    void apply(Tag t) {  // 懒标记作用到信息上",
            "        sum += t.add * len;",
            "        mx += t.add;",
            "        mn += t.add;",
            "    }",
            "};",
            "Info operator+(Info a, Info b) {",
            "    Info c;",
            "    c.sum = a.sum + b.sum;",
            "    c.len = a.len + b.len;",
            "    c.mx = max(a.mx, b.mx);",
            "    c.mn = min(a.mn, b.mn);",
            "    return c;",
            "}"
        ],
        "description": "线段树（懒标记）模板"
    },
	"Tree Template": {
        "scope": "c,cpp",
        "prefix": "Tree",
        "body": [
            "struct Tree {",
            "    int n;",
            "    vector<vector<int>> g;",
            "    vector<int> fa, dep, sz, son, top, val;",
            "    int pr[N], sf[N];",
            "    Tree(int n_) : n(n_), g(n), fa(n), dep(n), sz(n), son(n), top(n), val(n) {}",
            "",
            "    inline void add_edge(int u, int v) {",
            "        g[u].push_back(v);",
            "        g[v].push_back(u);",
            "    }",
            "    void dfs1(int u) {",
            "        sz[u] = 1;",
            "        dep[u] = dep[fa[u]] + 1;",
            "        for (auto v : g[u]) {",
            "            if (v == fa[u]) continue;",
            "            fa[v] = u;",
            "            dfs1(v);",
            "            sz[u] += sz[v];",
            "            if (sz[v] > sz[son[u]]) son[u] = v;",
            "        }",
            "    }",
            "    void dfs2(int u, int h) {",
            "        top[u] = h;",
            "        if (son[u]) dfs2(son[u], h);",
            "        for (auto v : g[u]) {",
            "            if (v == fa[u] || v == son[u]) continue;",
            "            dfs2(v, v);",
            "        }",
            "    }",
            "    int LCA(int x, int y) {",
            "        while (top[x] != top[y]) {",
            "            if (dep[top[x]] > dep[top[y]]) x = fa[top[x]];",
            "            else y = fa[top[y]];",
            "        }",
            "        return dep[x] < dep[y] ? x : y;",
            "    }",
            "    void init() {",
            "        dfs1(1);",
            "        dfs2(1, 1);",
            "    }",
            "};"
        ],
        "description": "Tree Template with LCA and HLD"
    },
	"Linear Sieve Function": {
        "scope": "c,cpp",
        "prefix": "get_primes",
        "body": [
            "//---线性筛----//",
            "vector<int> primes;",
            "vector<bool> isp;",
            "void get_primes(int n) {",
            "    isp.assign(n + 1, true);",
            "    isp[0] = isp[1] = false;",
            "    primes.clear();",
            "    for (int i = 2; i <= n; i++) {",
            "        if (isp[i]) primes.push_back(i);",
            "        for (int j = 0; j < primes.size() && primes[j] <= n / i; j++) {",
            "            isp[primes[j] * i] = false;",
            "            if (i % primes[j] == 0) break;",
            "        }",
            "    }",
            "}"
        ],
        "description": "Linear Sieve to find all primes up to n"
    },
    "Big Integer": {
        "scope": "c,cpp",
        "prefix": "LG",
        "body": [
            "using ull = unsigned long long;",
            "using i128 = __int128_t;",
            "using u128 = __uint128_t;",
            "",
            "template <typename T>",
            "void read(T& x) {",
            "    x = 0;",
            "    bool neg = false;",
            "    char c = getchar();",
            "    while (c < '0' || c > '9') {",
            "        if (c == '-') neg = true;",
            "        c = getchar();",
            "    }",
            "    while (c >= '0' && c <= '9') {",
            "        x = x * 10 + (c - '0');",
            "        c = getchar();",
            "    }",
            "    if (neg) x = -x;",
            "}",
            "",
            "template <typename T>",
            "void print(T x) {",
            "    if (x == 0) {",
            "        putchar('0');",
            "        return;",
            "    }",
            "    if (x < 0) {",
            "        putchar('-');",
            "        x = -x;",
            "    }",
            "    char buf[40];",
            "    int pos = 0;",
            "    while (x > 0) {",
            "        buf[pos++] = (x % 10) + '0';",
            "        x /= 10;",
            "    }",
            "    while (pos > 0) {",
            "        putchar(buf[--pos]);",
            "    }",
            "}"
        ],
        "description": "Larger Integer than long long"
    },
    "P3": {
        "scope": "c,cpp",
        "prefix": "P3",
        "body": [
            "struct P3 {",
            "    int first, second, third;",
            "    auto operator<=>(const P3&) const = default; // C++20",
            "};"
        ],
        "description": "pair of 3 elements" 
    },
    "CMP": {
        "scope": "c,cpp",
        "prefix": "CMP",
        "body": [
            "struct CMP {",
            "    bool operator()(const auto &x, const auto &y) const { ",
            "        return x < y;",
            "    }",
            "};"
        ],
        "description": "Custom Comparator" 
    },
    "ModTemplate": {
    "scope": "cpp",
    "prefix": "ModTemplate",
    "body": [
        "#undef int",
        "template <class T>",
        "constexpr T power(T a, u64 b, T res = 1) {",
        "    for (; b != 0; b /= 2, a *= a) {",
        "        if (b & 1) {",
        "            res *= a;",
        "        }",
        "    }",
        "    return res;",
        "}",
        "",
        "template <u32 P>",
        "constexpr u32 mulMod(u32 a, u32 b) {",
        "    return u64(a) * b % P;",
        "}",
        "",
        "template <u64 P>",
        "constexpr u64 mulMod(u64 a, u64 b) {",
        "    u64 res = a * b - u64(1.L * a * b / P - 0.5L) * P;",
        "    res %= P;",
        "    return res;",
        "}",
        "",
        "constexpr i64 safeMod(i64 x, i64 m) {",
        "    x %= m;",
        "    if (x < 0) {",
        "        x += m;",
        "    }",
        "    return x;",
        "}",
        "",
        "constexpr std::pair<i64, i64> invGcd(i64 a, i64 b) {",
        "    a = safeMod(a, b);",
        "    if (a == 0) {",
        "        return {b, 0};",
        "    }",
        "",
        "    i64 s = b, t = a;",
        "    i64 m0 = 0, m1 = 1;",
        "",
        "    while (t) {",
        "        i64 u = s / t;",
        "        s -= t * u;",
        "        m0 -= m1 * u;",
        "",
        "        std::swap(s, t);",
        "        std::swap(m0, m1);",
        "    }",
        "",
        "    if (m0 < 0) {",
        "        m0 += b / s;",
        "    }",
        "",
        "    return {s, m0};",
        "}",
        "",
        "template <std::unsigned_integral U, U P>",
        "struct ModIntBase {",
        "   public:",
        "    constexpr ModIntBase() : x(0) {}",
        "    template <std::unsigned_integral T>",
        "    constexpr ModIntBase(T x_) : x(x_ % mod()) {}",
        "    template <std::signed_integral T>",
        "    constexpr ModIntBase(T x_) {",
        "        using S = std::make_signed_t<U>;",
        "        S v = x_ % S(mod());",
        "        if (v < 0) {",
        "            v += mod();",
        "        }",
        "        x = v;",
        "    }",
        "",
        "    constexpr static U mod() { return P; }",
        "",
        "    constexpr U val() const { return x; }",
        "",
        "    constexpr ModIntBase operator-() const {",
        "        ModIntBase res;",
        "        res.x = (x == 0 ? 0 : mod() - x);",
        "        return res;",
        "    }",
        "",
        "    constexpr ModIntBase inv() const { return power(*this, mod() - 2); }",
        "",
        "    constexpr ModIntBase &operator*=(const ModIntBase &rhs) & {",
        "        x = mulMod<mod()>(x, rhs.val());",
        "        return *this;",
        "    }",
        "    constexpr ModIntBase &operator+=(const ModIntBase &rhs) & {",
        "        x += rhs.val();",
        "        if (x >= mod()) {",
        "            x -= mod();",
        "        }",
        "        return *this;",
        "    }",
        "    constexpr ModIntBase &operator-=(const ModIntBase &rhs) & {",
        "        x -= rhs.val();",
        "        if (x >= mod()) {",
        "            x += mod();",
        "        }",
        "        return *this;",
        "    }",
        "    constexpr ModIntBase &operator/=(const ModIntBase &rhs) & {",
        "        return *this *= rhs.inv();",
        "    }",
        "",
        "    friend constexpr ModIntBase operator*(ModIntBase lhs, const ModIntBase &rhs) {",
        "        lhs *= rhs;",
        "        return lhs;",
        "    }",
        "    friend constexpr ModIntBase operator+(ModIntBase lhs, const ModIntBase &rhs) {",
        "        lhs += rhs;",
        "        return lhs;",
        "    }",
        "    friend constexpr ModIntBase operator-(ModIntBase lhs, const ModIntBase &rhs) {",
        "        lhs -= rhs;",
        "        return lhs;",
        "    }",
        "    friend constexpr ModIntBase operator/(ModIntBase lhs, const ModIntBase &rhs) {",
        "        lhs /= rhs;",
        "        return lhs;",
        "    }",
        "",
        "    friend constexpr std::istream &operator>>(std::istream &is, ModIntBase &a) {",
        "        i64 i;",
        "        is >> i;",
        "        a = i;",
        "        return is;",
        "    }",
        "    friend constexpr std::ostream &operator<<(std::ostream &os, const ModIntBase &a) {",
        "        return os << a.val();",
        "    }",
        "",
        "    friend constexpr bool operator==(const ModIntBase &lhs, const ModIntBase &rhs) {",
        "        return lhs.val() == rhs.val();",
        "    }",
        "    friend constexpr std::strong_ordering operator<=>(const ModIntBase &lhs, const ModIntBase &rhs) {",
        "        return lhs.val() <=> rhs.val();",
        "    }",
        "",
        "   private:",
        "    U x;",
        "};",
        "",
        "template <u32 P>",
        "using ModInt = ModIntBase<u32, P>;",
        "template <u64 P>",
        "using ModInt64 = ModIntBase<u64, P>;",
        "",
        "struct Barrett {",
        "   public:",
        "    Barrett(u32 m_) : m(m_), im((u64)(-1) / m_ + 1) {}",
        "",
        "    constexpr u32 mod() const { return m; }",
        "",
        "    constexpr u32 mul(u32 a, u32 b) const {",
        "        u64 z = a;",
        "        z *= b;",
        "",
        "        u64 x = u64((u128(z) * im) >> 64);",
        "",
        "        u32 v = u32(z - x * m);",
        "        if (m <= v) {",
        "            v += m;",
        "        }",
        "        return v;",
        "    }",
        "",
        "   private:",
        "    u32 m;",
        "    u64 im;",
        "};",
        "",
        "template <u32 Id>",
        "struct DynModInt {",
        "   public:",
        "    constexpr DynModInt() : x(0) {}",
        "    template <std::unsigned_integral T>",
        "    constexpr DynModInt(T x_) : x(x_ % mod()) {}",
        "    template <std::signed_integral T>",
        "    constexpr DynModInt(T x_) {",
        "        auto v = x_ % static_cast<decltype(x_)>(mod());",
        "        if (v < 0) {",
        "            v += mod();",
        "        }",
        "        x = v;",
        "    }",
        "",
        "    constexpr static void setMod(u32 m) { bt = m; }",
        "",
        "    static u32 mod() { return bt.mod(); }",
        "",
        "    constexpr u32 val() const { return x; }",
        "",
        "    constexpr DynModInt operator-() const {",
        "        DynModInt res;",
        "        res.x = (x == 0 ? 0 : mod() - x);",
        "        return res;",
        "    }",
        "",
        "    constexpr DynModInt inv() const {",
        "        auto v = invGcd(x, mod());",
        "        assert(v.first == 1);",
        "        return v.second;",
        "    }",
        "",
        "    constexpr DynModInt &operator*=(const DynModInt &rhs) & {",
        "        x = bt.mul(x, rhs.val());",
        "        return *this;",
        "    }",
        "    constexpr DynModInt &operator+=(const DynModInt &rhs) & {",
        "        x += rhs.val();",
        "        if (x >= mod()) {",
        "            x -= mod();",
        "        }",
        "        return *this;",
        "    }",
        "    constexpr DynModInt &operator-=(const DynModInt &rhs) & {",
        "        x -= rhs.val();",
        "        if (x >= mod()) {",
        "            x += mod();",
        "        }",
        "        return *this;",
        "    }",
        "    constexpr DynModInt &operator/=(const DynModInt &rhs) & {",
        "        return *this *= rhs.inv();",
        "    }",
        "",
        "    friend constexpr DynModInt operator*(DynModInt lhs, const DynModInt &rhs) {",
        "        lhs *= rhs;",
        "        return lhs;",
        "    }",
        "    friend constexpr DynModInt operator+(DynModInt lhs, const DynModInt &rhs) {",
        "        lhs += rhs;",
        "        return lhs;",
        "    }",
        "    friend constexpr DynModInt operator-(DynModInt lhs, const DynModInt &rhs) {",
        "        lhs -= rhs;",
        "        return lhs;",
        "    }",
        "    friend constexpr DynModInt operator/(DynModInt lhs, const DynModInt &rhs) {",
        "        lhs /= rhs;",
        "        return lhs;",
        "    }",
        "",
        "    friend constexpr std::istream &operator>>(std::istream &is, DynModInt &a) {",
        "        i64 i;",
        "        is >> i;",
        "        a = i;",
        "        return is;",
        "    }",
        "    friend constexpr std::ostream &operator<<(std::ostream &os, const DynModInt &a) {",
        "        return os << a.val();",
        "    }",
        "",
        "    friend constexpr bool operator==(const DynModInt &lhs, const DynModInt &rhs) {",
        "        return lhs.val() == rhs.val();",
        "    }",
        "    friend constexpr std::strong_ordering operator<=>(const DynModInt &lhs, const DynModInt &rhs) {",
        "        return lhs.val() <=> rhs.val();",
        "    }",
        "",
        "   private:",
        "    u32 x;",
        "    static Barrett bt;",
        "};",
        "",
        "template <u32 Id>",
        "Barrett DynModInt<Id>::bt = 998244353;",
        "",
        "// using D = DynModInt<0>;",
        "",
        "using Z = ModInt<998244353>;",
        "// using Z = ModInt<(int)1E9+7>;",
        "using ZL = ModInt64<(i64)1E18 + 7>;",
        "#define int long long",
        "",
        "Z fac[N + 5], invfac[N + 5];",
        "void init_combination() {",
        "    fac[0] = invfac[0] = 1;",
        "    for (int i = 1; i <= N; i++) fac[i] = fac[i - 1] * i;",
        "    invfac[N] = fac[N].inv();",
        "    for (int i = N - 1; i; i--) invfac[i] = invfac[i + 1] * (i + 1);",
        "}",
        "inline Z A(int a, int b) {",
        "    if (a < 0 || b < 0 || a < b) return 0;",
        "    return fac[a] * invfac[a - b];",
        "}",
        "inline Z C(int a, int b) {",
        "    if (a < 0 || b < 0 || a < b) return 0;",
        "    return fac[a] * invfac[b] * invfac[a - b];",
        "}"
    ],
    "description": "模数模板（包含ModInt，DynModInt和组合数计算）"
}
}